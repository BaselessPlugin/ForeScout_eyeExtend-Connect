<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>connectproxyserver API documentation</title>
<meta name="description" content="Copyright © 2021 Forescout Technologies, Inc …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>connectproxyserver</code></h1>
</header>
<section id="section-intro">
<p>Copyright © 2021 Forescout Technologies, Inc.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright © 2021 Forescout Technologies, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#34;Software&#34;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&#34;&#34;&#34;

import logging
import requests
import urllib.request
from requests.auth import HTTPProxyAuth
from enum import Enum


class ProxyProtocol(Enum):
    &#34;&#34;&#34; Choices for proxy server proxies

    Indicate what proxy server proxies (string) shall use in the request. Can
    be all, http, https or none. If proxy server supports both protocols,
    can use ProxyProtocol.all. It is a good practise to use
    ProxyProtocol.all if supporting both protocols. If only support http, then
    use ProxyProtocol.http. If support https, then use ProxyProtocol.https.
    &#34;&#34;&#34;
    all = 1
    http = 2
    https = 3
    none = 4


class ConnectProxyServer:
    &#34;&#34;&#34; ConnectProxyServer

    This class will take param as input and setup proxy server info if there
    is any in the constructor. User can use class methods that 1) use
    requests or 2) use urllib.request to invoke http requests. If proxy
    server is enabled, both the proxy IP and proxy port are required, in this
    case, if not specified, ValueError is raised. Username and password for
    the proxy serve are optional. Only when proxy server is enabled,
    which specified in params.get(&#34;connect_proxy_enable&#34;), proxy server info
    is used in the method calls. When constructed, the self.proxies is None.

    :keyword params, variables passed by the connect script

    - connect_proxy_enable, if not specified or false, indicate no proxy server.

    - connect_proxy_ip, required when connect_proxy_enable is true

    - connect_proxy_port, required when connect_proxy_enabled is true

    - connect_proxy_username, optional

    - connect_proxy_password, optional

    :raise ValueError if proxy server is enabled and proxy ip or port is not specified
    &#34;&#34;&#34;
    def __init__(self, params):
        is_proxy_enabled = params.get(&#34;connect_proxy_enable&#34;)
        logging.debug(&#34;Proxy enabled status: &#34; + str(is_proxy_enabled))
        if is_proxy_enabled == &#34;true&#34;:  # Cover the case is_proxy_enable is None, it is not equal to &#34;true&#34;
            #: A boolean to indicate if the proxy server is enabled
            self.is_enabled = True
        else:
            self.is_enabled = False
        if self.is_enabled:
            #: Proxy server ip. None if proxy server is not enabled.
            # Required if proxy server is enabled, otherwise, a ValueError is
            # raised
            self.ip = params.get(&#34;connect_proxy_ip&#34;)
            if not self.ip:
                raise ValueError(&#34;Proxy IP is empty or null.&#34;)
            #: Proxy server port. None if proxy server is not enabled.
            # Required if proxy server is enabled, otherwise, a ValueError is
            # raised
            self.port = params.get(&#34;connect_proxy_port&#34;)
            if not self.port:
                raise ValueError(&#34;Proxy port is empty or null.&#34;)

            # Username and password can be null
            #: Proxy server username. (Optional), None if proxy server is not enabled.
            self.username = params.get(&#34;connect_proxy_username&#34;)
            #: Proxy server password. (Optional), None if proxy server is not enabled.
            self.password = params.get(&#34;connect_proxy_password&#34;)
        else:
            self.ip = None
            self.port = None
            self.username = None
            self.password = None
        # : Proxies, default is none
        self.proxies = None
        logging.debug(f&#34;Proxy IP: {self.ip}&#34;)
        logging.debug(f&#34;Proxy port: {self.port}&#34;)
        logging.debug(f&#34;Proxy username: {self.username}&#34;)

    def get_proxies(self, protocol=ProxyProtocol.https):
        &#34;&#34;&#34; Returns proxies string used to connect to proxy server base on
        protocol passed in.

        The proxies will contain username, password and port info in required
        format to connect to proxy server
        :param protocol: Proxy server protocol to use.
            Value can be ProxyProtocol.https, ProxyProtocol.http or
            ProxyProtocol.none. Default is ProxyProtocol.https.

        :return: Proxies in hash with proxy server info set
        &#34;&#34;&#34;
        proxies = {
            &#34;https:&#34;: None,
            &#34;http:&#34;: None
        }

        if ProxyProtocol.none == protocol:
            return proxies

        if ProxyProtocol.https == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
                }
        elif ProxyProtocol.http == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port)
                }
        elif ProxyProtocol.all == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
                }
        return proxies

    def get_empty_proxies_string(self):
        return self.get_proxies(ProxyProtocol.none)

    @staticmethod
    def set_no_cache_connection_pool():
        &#34;&#34;&#34; Do not cache the pool&#34;&#34;&#34;
        with requests.Session() as session:
            adapter = requests.adapters.HTTPAdapter(pool_connections=0)
            logging.debug(&#34;Clear connection pool.&#34;)
            session.mount(&#34;https://&#34;, adapter)
            session.mount(&#34;http://&#34;, adapter)

    @staticmethod
    def set_default_connection_pool():
        &#34;&#34;&#34; Default connection pool setting &#34;&#34;&#34;
        with requests.Session() as session:
            logging.debug(&#34;Set default connection pool.&#34;)
            session.mount(&#34;https://&#34;, requests.adapters.HTTPAdapter())
            session.mount(&#34;http://&#34;, requests.adapters.HTTPAdapter())

    def get_requests_session(self, protocol=ProxyProtocol.https, **kwargs):
        &#34;&#34;&#34; Get a requests session with proxy server info set.

        Method will check if the proxy is enabled or not. And after getting
        the requests session, user can use post, delete, put whatever
        requests session supports to invoke a http request. By using this
        method, user proxy server is transparent to the user. The proxy
        server configuration is set. Check sessions to see what variables can
        be passed in details:

        https://requests.readthedocs.io/en/master/api/#request-sessions

        Typical usage example:

            - Use session with headers and verify SSL context (accepts most of requests.Session accepts)

            proxy_server = ConnectProxyServer(params)
            with proxy_server.get_requests_session(
                ProxyProtocol.https,
                headers=headers,
                verify=ssl_verify) as session:
                post_response = session.post(token_url, json=payload)
                delete_response = session.delete(delete_user_url)

            session will be closed on exiting the with block

            - Use session with SSL context in post request (which accepts everything requests.request accepts)

            proxy_server = ConnectProxyServer(params)

            session =proxy_server.get_requests_session(ProxyProtocol.https,headers=device_headers, verify=ssl_verify)

            add_response = session.post(add_user_url, json=json_body)

            get_response = session.get(get_user_url)

            proxy_server = ConnectProxyServer(params)

            session = proxy_server.get_requests_session(ProxyProtocol.https)

            add_response = session.post(add_user_url, json=json_body, verify=ssl_verify, headers=headers)

        :param self:

        :param protocol: Proxies to use in the session for the proxy server if
        proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
        or ProxyProtocol.none. Default is ProxyProtocol.https.
        This sets the session proxies, auth in HTTPProxyAuth and trust_env.

        :param kwargs: (optional) Any arguments that requests.session supports,
        except proxies, auth and trust_env, passed as &#34;headers=headerValue&#34;,
        for example. User can also pass the value via session methods such as
        post, get, delete etc. you can also pass use_cache=true which will
        persist in connection pool. By default we don&#39;t cache the connection in
        the connection pool.

        :return: A requests.session that has proxy server configured.
        &#34;&#34;&#34;
        # By default, we don&#39;t put the connection back to the connection pool
        # So each session is a new connection. User can chose to use default
        # connection pool, then connection from connection pool would persist
        if kwargs.get(&#34;use_cache&#34;):
            self.set_default_connection_pool()
        else:
            self.set_no_cache_connection_pool()

        session = requests.Session()
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            # Set proxy ones for entire session
            session.auth = HTTPProxyAuth(self.username, self.password)
            session.proxies.update(proxies)
            self.proxies = proxies
        else:
            proxies = self.get_empty_proxies_string()
            session.proxies.update(proxies)
            session.auth = None
            self.proxies = proxies
        # Not trusting default env
        session.trust_env = False

        # Set the variables that session supports. Not including proxies,
        # auth and trust_env. However, There is nothing prevents caller to
        # get the session first then override proxies, auth and trust_env
        if kwargs.get(&#34;cert&#34;):
            session.cert = kwargs.get(&#34;cert&#34;)
        if kwargs.get(&#34;cookies&#34;):
            session.cookies = kwargs.get(&#34;cookies&#34;)
        if kwargs.get(&#34;headers&#34;):
            session.headers = kwargs.get(&#34;headers&#34;)
        if kwargs.get(&#34;hooks&#34;):
            session.hooks = kwargs.get(&#34;hooks&#34;)
        if kwargs.get(&#34;max_redirects&#34;):
            session.max_redirects = kwargs.get(&#34;max_redirects&#34;)
        if kwargs.get(&#34;params&#34;):
            session.params = kwargs.get(&#34;params&#34;)
        if kwargs.get(&#34;stream&#34;):
            session.stream = kwargs.get(&#34;stream&#34;)
        if kwargs.get(&#34;verify&#34;):
            session.verify = kwargs.get(&#34;verify&#34;)
        return session

    def get_urllib_request_opener(self, protocol=ProxyProtocol.https, *handlers):
        &#34;&#34;&#34; Get a urllib request opener with proxy server configured

        Get a request opener that can has proxy server set and user can use
        opener.open or urllib.request.urlopen after this method to connect to
        invoke a http request. To check out opener,
        see: https://docs.python.org/3/library/urllib.request.html#urllib.request.build_opener

        Typical usage example:

            -  Use open, pass handlers

            auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

            ssl_handler = urllib.request.HTTPSHandler(context=ssl_context)

            proxy_server = AppProxyServer(params)

            opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

            response = opener_build_opener.open(https_url)

            - Use urlopen, pass handlers

            proxy_server = AppProxyServer(params)

            opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

            response = urllib.request.urlopen(https_url)

            - Use urlopen, pass info on request

            proxy_server = ConnectProxyServer(params)

            # HTTPS or HTTP or both in the protocol, pass down the ssl_context
            https_handler = urllib.request.HTTPSHandler(context=ssl_context)

            opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, https_handler)

            get_user_request = urllib.request.Request(get_users_url, headers=device_headers)

            get_user_response = urllib.request.urlopen(get_user_request)

        :param protocol: Proxies to use in the request for the proxy server
        If proxy server is enabled, can be ProxyProtocol.https,
        ProxyProtocol.http or ProxyProtocol.none. Default is
        ProxyProtocol.https.

        :param handlers: (optional) Handlers that urllib.request.build_opener accepts, such as HTTPSHandler.

        :return: opener: OpenerDirector from urllib.request.build_opener that has ProxyHandler set. The consequent
        request call can use opener.open or urllib.request.urlopen.
        &#34;&#34;&#34;
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            proxy_handler = urllib.request.ProxyHandler(proxies)
            opener = urllib.request.build_opener(proxy_handler, *handlers)
            self.proxies = proxies
        else:
            proxy_handler = urllib.request.ProxyHandler({})
            opener = urllib.request.build_opener(proxy_handler, *handlers)
            self.proxies = self.get_empty_proxies_string()

        # This is needed to enable opener to able to call urllib.request.urlopen
        urllib.request.install_opener(opener)
        return opener

    def get_urllib_request_https_opener(self, protocol=ProxyProtocol.https, ssl_context=None, basic_auth=None):
        &#34;&#34;&#34; Get a urllib request opener with proxy server configured with
        ssl_context and HTTP basic auth handler set.

        Similar to method get_urllib_request_opener, if you want methods to
        set ssl_context and basic auth. The method has HTTPSHandler with SSL
        context and HTTPBasicAuthHandler set for the opener. User can use
        opener.open or urllib.request.urlopen after this method to connect to
        invoke a http request.

        Typical usage example:

            - Use urlopen with ssl_context and HTTPPasswordMgrWithDefaultRealm

            password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()

            password_mgr.add_password(None, https_url, https_client_id, https_client_secret)

            proxy_server = AppProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context, password_mgr)

            response = urllib.request.urlopen(CrowdStrike_HTTPS_URL)

            - Use urlopen, with ssl_context

            proxy_server = AppProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

            http_post_request = urllib.request.Request(https_url, http_post_data.encode(&#39;utf-8&#39;), method=&#39;POST&#39;)

            http_post_request.add_header(&#34;Content-Type&#34;, &#34;application/x-www-form-urlencoded&#34;)

            http_post_request.add_header(&#34;accept&#34;, &#34;application/json&#34;)

            # Use opener.open to get the request ( you can use urlopen as well, look at resolve script
            response = urllib.request.urlopen(http_post_request)

            - Use open, with ssl_context

            proxy_server = ConnectProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

            poll_request = urllib.request.Request(get_mac_url, headers=device_headers)

            poll_response = opener.open(poll_request)


        Check out HTTPBasicAuthHandler, see:
        https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPPasswordMgr

        :param protocol: Proxies to use in the session for the proxy server if
        proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
        or ProxyProtocol.none. Default is ProxyProtocol.https.

        :param ssl_context: ssl_context passed to the context in the
        HTTPSHandler. Default is None.

        :param basic_auth:
        HTTPPasswordMgr or similar passed to create HTTPBasicAuthHandler.
        Default is None.

        :return: opener: OpenerDirector from urllib.request.build_opener that
        has ProxyHandler, HTTPSHandler with SSL context and
        HTTPBasicAuthHandler set. The consequent request call can use
        opener.open or urllib.request.urlopen.
        &#34;&#34;&#34;
        if ssl_context:
            https_handler = urllib.request.HTTPSHandler(context=ssl_context)
        else:
            https_handler = urllib.request.HTTPSHandler()
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            proxy_handler = urllib.request.ProxyHandler(proxies)
            self.proxies = proxies
        else:
            self.proxies = self.get_empty_proxies_string()

        if basic_auth:
            auth_handler = urllib.request.HTTPBasicAuthHandler(basic_auth)
        else:
            auth_handler = urllib.request.HTTPBasicAuthHandler()

        if self.is_enabled:
            opener = urllib.request.build_opener(proxy_handler, auth_handler, https_handler)
        else:
            opener = urllib.request.build_opener(auth_handler, https_handler)

        # This is needed to able opener to able to call urlopen
        urllib.request.install_opener(opener)
        return opener</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="connectproxyserver.ConnectProxyServer"><code class="flex name class">
<span>class <span class="ident">ConnectProxyServer</span></span>
<span>(</span><span>params)</span>
</code></dt>
<dd>
<div class="desc"><p>ConnectProxyServer</p>
<p>This class will take param as input and setup proxy server info if there
is any in the constructor. User can use class methods that 1) use
requests or 2) use urllib.request to invoke http requests. If proxy
server is enabled, both the proxy IP and proxy port are required, in this
case, if not specified, ValueError is raised. Username and password for
the proxy serve are optional. Only when proxy server is enabled,
which specified in params.get("connect_proxy_enable"), proxy server info
is used in the method calls. When constructed, the self.proxies is None.</p>
<p>:keyword params, variables passed by the connect script</p>
<ul>
<li>
<p>connect_proxy_enable, if not specified or false, indicate no proxy server.</p>
</li>
<li>
<p>connect_proxy_ip, required when connect_proxy_enable is true</p>
</li>
<li>
<p>connect_proxy_port, required when connect_proxy_enabled is true</p>
</li>
<li>
<p>connect_proxy_username, optional</p>
</li>
<li>
<p>connect_proxy_password, optional</p>
</li>
</ul>
<p>:raise ValueError if proxy server is enabled and proxy ip or port is not specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectProxyServer:
    &#34;&#34;&#34; ConnectProxyServer

    This class will take param as input and setup proxy server info if there
    is any in the constructor. User can use class methods that 1) use
    requests or 2) use urllib.request to invoke http requests. If proxy
    server is enabled, both the proxy IP and proxy port are required, in this
    case, if not specified, ValueError is raised. Username and password for
    the proxy serve are optional. Only when proxy server is enabled,
    which specified in params.get(&#34;connect_proxy_enable&#34;), proxy server info
    is used in the method calls. When constructed, the self.proxies is None.

    :keyword params, variables passed by the connect script

    - connect_proxy_enable, if not specified or false, indicate no proxy server.

    - connect_proxy_ip, required when connect_proxy_enable is true

    - connect_proxy_port, required when connect_proxy_enabled is true

    - connect_proxy_username, optional

    - connect_proxy_password, optional

    :raise ValueError if proxy server is enabled and proxy ip or port is not specified
    &#34;&#34;&#34;
    def __init__(self, params):
        is_proxy_enabled = params.get(&#34;connect_proxy_enable&#34;)
        logging.debug(&#34;Proxy enabled status: &#34; + str(is_proxy_enabled))
        if is_proxy_enabled == &#34;true&#34;:  # Cover the case is_proxy_enable is None, it is not equal to &#34;true&#34;
            #: A boolean to indicate if the proxy server is enabled
            self.is_enabled = True
        else:
            self.is_enabled = False
        if self.is_enabled:
            #: Proxy server ip. None if proxy server is not enabled.
            # Required if proxy server is enabled, otherwise, a ValueError is
            # raised
            self.ip = params.get(&#34;connect_proxy_ip&#34;)
            if not self.ip:
                raise ValueError(&#34;Proxy IP is empty or null.&#34;)
            #: Proxy server port. None if proxy server is not enabled.
            # Required if proxy server is enabled, otherwise, a ValueError is
            # raised
            self.port = params.get(&#34;connect_proxy_port&#34;)
            if not self.port:
                raise ValueError(&#34;Proxy port is empty or null.&#34;)

            # Username and password can be null
            #: Proxy server username. (Optional), None if proxy server is not enabled.
            self.username = params.get(&#34;connect_proxy_username&#34;)
            #: Proxy server password. (Optional), None if proxy server is not enabled.
            self.password = params.get(&#34;connect_proxy_password&#34;)
        else:
            self.ip = None
            self.port = None
            self.username = None
            self.password = None
        # : Proxies, default is none
        self.proxies = None
        logging.debug(f&#34;Proxy IP: {self.ip}&#34;)
        logging.debug(f&#34;Proxy port: {self.port}&#34;)
        logging.debug(f&#34;Proxy username: {self.username}&#34;)

    def get_proxies(self, protocol=ProxyProtocol.https):
        &#34;&#34;&#34; Returns proxies string used to connect to proxy server base on
        protocol passed in.

        The proxies will contain username, password and port info in required
        format to connect to proxy server
        :param protocol: Proxy server protocol to use.
            Value can be ProxyProtocol.https, ProxyProtocol.http or
            ProxyProtocol.none. Default is ProxyProtocol.https.

        :return: Proxies in hash with proxy server info set
        &#34;&#34;&#34;
        proxies = {
            &#34;https:&#34;: None,
            &#34;http:&#34;: None
        }

        if ProxyProtocol.none == protocol:
            return proxies

        if ProxyProtocol.https == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
                }
        elif ProxyProtocol.http == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port)
                }
        elif ProxyProtocol.all == protocol:
            if self.username and self.password:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
                }
            elif self.username and not self.password:
                proxies = {
                    &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
                }
            else:
                proxies = {
                    &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port),
                    &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
                }
        return proxies

    def get_empty_proxies_string(self):
        return self.get_proxies(ProxyProtocol.none)

    @staticmethod
    def set_no_cache_connection_pool():
        &#34;&#34;&#34; Do not cache the pool&#34;&#34;&#34;
        with requests.Session() as session:
            adapter = requests.adapters.HTTPAdapter(pool_connections=0)
            logging.debug(&#34;Clear connection pool.&#34;)
            session.mount(&#34;https://&#34;, adapter)
            session.mount(&#34;http://&#34;, adapter)

    @staticmethod
    def set_default_connection_pool():
        &#34;&#34;&#34; Default connection pool setting &#34;&#34;&#34;
        with requests.Session() as session:
            logging.debug(&#34;Set default connection pool.&#34;)
            session.mount(&#34;https://&#34;, requests.adapters.HTTPAdapter())
            session.mount(&#34;http://&#34;, requests.adapters.HTTPAdapter())

    def get_requests_session(self, protocol=ProxyProtocol.https, **kwargs):
        &#34;&#34;&#34; Get a requests session with proxy server info set.

        Method will check if the proxy is enabled or not. And after getting
        the requests session, user can use post, delete, put whatever
        requests session supports to invoke a http request. By using this
        method, user proxy server is transparent to the user. The proxy
        server configuration is set. Check sessions to see what variables can
        be passed in details:

        https://requests.readthedocs.io/en/master/api/#request-sessions

        Typical usage example:

            - Use session with headers and verify SSL context (accepts most of requests.Session accepts)

            proxy_server = ConnectProxyServer(params)
            with proxy_server.get_requests_session(
                ProxyProtocol.https,
                headers=headers,
                verify=ssl_verify) as session:
                post_response = session.post(token_url, json=payload)
                delete_response = session.delete(delete_user_url)

            session will be closed on exiting the with block

            - Use session with SSL context in post request (which accepts everything requests.request accepts)

            proxy_server = ConnectProxyServer(params)

            session =proxy_server.get_requests_session(ProxyProtocol.https,headers=device_headers, verify=ssl_verify)

            add_response = session.post(add_user_url, json=json_body)

            get_response = session.get(get_user_url)

            proxy_server = ConnectProxyServer(params)

            session = proxy_server.get_requests_session(ProxyProtocol.https)

            add_response = session.post(add_user_url, json=json_body, verify=ssl_verify, headers=headers)

        :param self:

        :param protocol: Proxies to use in the session for the proxy server if
        proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
        or ProxyProtocol.none. Default is ProxyProtocol.https.
        This sets the session proxies, auth in HTTPProxyAuth and trust_env.

        :param kwargs: (optional) Any arguments that requests.session supports,
        except proxies, auth and trust_env, passed as &#34;headers=headerValue&#34;,
        for example. User can also pass the value via session methods such as
        post, get, delete etc. you can also pass use_cache=true which will
        persist in connection pool. By default we don&#39;t cache the connection in
        the connection pool.

        :return: A requests.session that has proxy server configured.
        &#34;&#34;&#34;
        # By default, we don&#39;t put the connection back to the connection pool
        # So each session is a new connection. User can chose to use default
        # connection pool, then connection from connection pool would persist
        if kwargs.get(&#34;use_cache&#34;):
            self.set_default_connection_pool()
        else:
            self.set_no_cache_connection_pool()

        session = requests.Session()
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            # Set proxy ones for entire session
            session.auth = HTTPProxyAuth(self.username, self.password)
            session.proxies.update(proxies)
            self.proxies = proxies
        else:
            proxies = self.get_empty_proxies_string()
            session.proxies.update(proxies)
            session.auth = None
            self.proxies = proxies
        # Not trusting default env
        session.trust_env = False

        # Set the variables that session supports. Not including proxies,
        # auth and trust_env. However, There is nothing prevents caller to
        # get the session first then override proxies, auth and trust_env
        if kwargs.get(&#34;cert&#34;):
            session.cert = kwargs.get(&#34;cert&#34;)
        if kwargs.get(&#34;cookies&#34;):
            session.cookies = kwargs.get(&#34;cookies&#34;)
        if kwargs.get(&#34;headers&#34;):
            session.headers = kwargs.get(&#34;headers&#34;)
        if kwargs.get(&#34;hooks&#34;):
            session.hooks = kwargs.get(&#34;hooks&#34;)
        if kwargs.get(&#34;max_redirects&#34;):
            session.max_redirects = kwargs.get(&#34;max_redirects&#34;)
        if kwargs.get(&#34;params&#34;):
            session.params = kwargs.get(&#34;params&#34;)
        if kwargs.get(&#34;stream&#34;):
            session.stream = kwargs.get(&#34;stream&#34;)
        if kwargs.get(&#34;verify&#34;):
            session.verify = kwargs.get(&#34;verify&#34;)
        return session

    def get_urllib_request_opener(self, protocol=ProxyProtocol.https, *handlers):
        &#34;&#34;&#34; Get a urllib request opener with proxy server configured

        Get a request opener that can has proxy server set and user can use
        opener.open or urllib.request.urlopen after this method to connect to
        invoke a http request. To check out opener,
        see: https://docs.python.org/3/library/urllib.request.html#urllib.request.build_opener

        Typical usage example:

            -  Use open, pass handlers

            auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

            ssl_handler = urllib.request.HTTPSHandler(context=ssl_context)

            proxy_server = AppProxyServer(params)

            opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

            response = opener_build_opener.open(https_url)

            - Use urlopen, pass handlers

            proxy_server = AppProxyServer(params)

            opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

            response = urllib.request.urlopen(https_url)

            - Use urlopen, pass info on request

            proxy_server = ConnectProxyServer(params)

            # HTTPS or HTTP or both in the protocol, pass down the ssl_context
            https_handler = urllib.request.HTTPSHandler(context=ssl_context)

            opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, https_handler)

            get_user_request = urllib.request.Request(get_users_url, headers=device_headers)

            get_user_response = urllib.request.urlopen(get_user_request)

        :param protocol: Proxies to use in the request for the proxy server
        If proxy server is enabled, can be ProxyProtocol.https,
        ProxyProtocol.http or ProxyProtocol.none. Default is
        ProxyProtocol.https.

        :param handlers: (optional) Handlers that urllib.request.build_opener accepts, such as HTTPSHandler.

        :return: opener: OpenerDirector from urllib.request.build_opener that has ProxyHandler set. The consequent
        request call can use opener.open or urllib.request.urlopen.
        &#34;&#34;&#34;
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            proxy_handler = urllib.request.ProxyHandler(proxies)
            opener = urllib.request.build_opener(proxy_handler, *handlers)
            self.proxies = proxies
        else:
            proxy_handler = urllib.request.ProxyHandler({})
            opener = urllib.request.build_opener(proxy_handler, *handlers)
            self.proxies = self.get_empty_proxies_string()

        # This is needed to enable opener to able to call urllib.request.urlopen
        urllib.request.install_opener(opener)
        return opener

    def get_urllib_request_https_opener(self, protocol=ProxyProtocol.https, ssl_context=None, basic_auth=None):
        &#34;&#34;&#34; Get a urllib request opener with proxy server configured with
        ssl_context and HTTP basic auth handler set.

        Similar to method get_urllib_request_opener, if you want methods to
        set ssl_context and basic auth. The method has HTTPSHandler with SSL
        context and HTTPBasicAuthHandler set for the opener. User can use
        opener.open or urllib.request.urlopen after this method to connect to
        invoke a http request.

        Typical usage example:

            - Use urlopen with ssl_context and HTTPPasswordMgrWithDefaultRealm

            password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()

            password_mgr.add_password(None, https_url, https_client_id, https_client_secret)

            proxy_server = AppProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context, password_mgr)

            response = urllib.request.urlopen(CrowdStrike_HTTPS_URL)

            - Use urlopen, with ssl_context

            proxy_server = AppProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

            http_post_request = urllib.request.Request(https_url, http_post_data.encode(&#39;utf-8&#39;), method=&#39;POST&#39;)

            http_post_request.add_header(&#34;Content-Type&#34;, &#34;application/x-www-form-urlencoded&#34;)

            http_post_request.add_header(&#34;accept&#34;, &#34;application/json&#34;)

            # Use opener.open to get the request ( you can use urlopen as well, look at resolve script
            response = urllib.request.urlopen(http_post_request)

            - Use open, with ssl_context

            proxy_server = ConnectProxyServer(params)

            opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

            poll_request = urllib.request.Request(get_mac_url, headers=device_headers)

            poll_response = opener.open(poll_request)


        Check out HTTPBasicAuthHandler, see:
        https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPPasswordMgr

        :param protocol: Proxies to use in the session for the proxy server if
        proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
        or ProxyProtocol.none. Default is ProxyProtocol.https.

        :param ssl_context: ssl_context passed to the context in the
        HTTPSHandler. Default is None.

        :param basic_auth:
        HTTPPasswordMgr or similar passed to create HTTPBasicAuthHandler.
        Default is None.

        :return: opener: OpenerDirector from urllib.request.build_opener that
        has ProxyHandler, HTTPSHandler with SSL context and
        HTTPBasicAuthHandler set. The consequent request call can use
        opener.open or urllib.request.urlopen.
        &#34;&#34;&#34;
        if ssl_context:
            https_handler = urllib.request.HTTPSHandler(context=ssl_context)
        else:
            https_handler = urllib.request.HTTPSHandler()
        if self.is_enabled:
            proxies = self.get_proxies(protocol)
            proxy_handler = urllib.request.ProxyHandler(proxies)
            self.proxies = proxies
        else:
            self.proxies = self.get_empty_proxies_string()

        if basic_auth:
            auth_handler = urllib.request.HTTPBasicAuthHandler(basic_auth)
        else:
            auth_handler = urllib.request.HTTPBasicAuthHandler()

        if self.is_enabled:
            opener = urllib.request.build_opener(proxy_handler, auth_handler, https_handler)
        else:
            opener = urllib.request.build_opener(auth_handler, https_handler)

        # This is needed to able opener to able to call urlopen
        urllib.request.install_opener(opener)
        return opener</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="connectproxyserver.ConnectProxyServer.set_default_connection_pool"><code class="name flex">
<span>def <span class="ident">set_default_connection_pool</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Default connection pool setting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_default_connection_pool():
    &#34;&#34;&#34; Default connection pool setting &#34;&#34;&#34;
    with requests.Session() as session:
        logging.debug(&#34;Set default connection pool.&#34;)
        session.mount(&#34;https://&#34;, requests.adapters.HTTPAdapter())
        session.mount(&#34;http://&#34;, requests.adapters.HTTPAdapter())</code></pre>
</details>
</dd>
<dt id="connectproxyserver.ConnectProxyServer.set_no_cache_connection_pool"><code class="name flex">
<span>def <span class="ident">set_no_cache_connection_pool</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Do not cache the pool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_no_cache_connection_pool():
    &#34;&#34;&#34; Do not cache the pool&#34;&#34;&#34;
    with requests.Session() as session:
        adapter = requests.adapters.HTTPAdapter(pool_connections=0)
        logging.debug(&#34;Clear connection pool.&#34;)
        session.mount(&#34;https://&#34;, adapter)
        session.mount(&#34;http://&#34;, adapter)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="connectproxyserver.ConnectProxyServer.get_empty_proxies_string"><code class="name flex">
<span>def <span class="ident">get_empty_proxies_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_empty_proxies_string(self):
    return self.get_proxies(ProxyProtocol.none)</code></pre>
</details>
</dd>
<dt id="connectproxyserver.ConnectProxyServer.get_proxies"><code class="name flex">
<span>def <span class="ident">get_proxies</span></span>(<span>self, protocol=ProxyProtocol.https)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns proxies string used to connect to proxy server base on
protocol passed in.</p>
<p>The proxies will contain username, password and port info in required
format to connect to proxy server
:param protocol: Proxy server protocol to use.
Value can be ProxyProtocol.https, ProxyProtocol.http or
ProxyProtocol.none. Default is ProxyProtocol.https.</p>
<p>:return: Proxies in hash with proxy server info set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proxies(self, protocol=ProxyProtocol.https):
    &#34;&#34;&#34; Returns proxies string used to connect to proxy server base on
    protocol passed in.

    The proxies will contain username, password and port info in required
    format to connect to proxy server
    :param protocol: Proxy server protocol to use.
        Value can be ProxyProtocol.https, ProxyProtocol.http or
        ProxyProtocol.none. Default is ProxyProtocol.https.

    :return: Proxies in hash with proxy server info set
    &#34;&#34;&#34;
    proxies = {
        &#34;https:&#34;: None,
        &#34;http:&#34;: None
    }

    if ProxyProtocol.none == protocol:
        return proxies

    if ProxyProtocol.https == protocol:
        if self.username and self.password:
            proxies = {
                &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
            }
        elif self.username and not self.password:
            proxies = {
                &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
            }
        else:
            proxies = {
                &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
            }
    elif ProxyProtocol.http == protocol:
        if self.username and self.password:
            proxies = {
                &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
            }
        elif self.username and not self.password:
            proxies = {
                &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
            }
        else:
            proxies = {
                &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port)
            }
    elif ProxyProtocol.all == protocol:
        if self.username and self.password:
            proxies = {
                &#34;http&#34;: &#34;http://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port),
                &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, self.password, self.ip, self.port)
            }
        elif self.username and not self.password:
            proxies = {
                &#34;http&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port),
                &#34;https&#34;: &#34;https://{}:{}@{}:{}&#34;.format(self.username, &#34;&#34;, self.ip, self.port)
            }
        else:
            proxies = {
                &#34;http&#34;: &#34;http://{}:{}&#34;.format(self.ip, self.port),
                &#34;https&#34;: &#34;https://{}:{}&#34;.format(self.ip, self.port)
            }
    return proxies</code></pre>
</details>
</dd>
<dt id="connectproxyserver.ConnectProxyServer.get_requests_session"><code class="name flex">
<span>def <span class="ident">get_requests_session</span></span>(<span>self, protocol=ProxyProtocol.https, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a requests session with proxy server info set.</p>
<p>Method will check if the proxy is enabled or not. And after getting
the requests session, user can use post, delete, put whatever
requests session supports to invoke a http request. By using this
method, user proxy server is transparent to the user. The proxy
server configuration is set. Check sessions to see what variables can
be passed in details:</p>
<p><a href="https://requests.readthedocs.io/en/master/api/#request-sessions">https://requests.readthedocs.io/en/master/api/#request-sessions</a></p>
<p>Typical usage example:</p>
<pre><code>- Use session with headers and verify SSL context (accepts most of requests.Session accepts)

proxy_server = ConnectProxyServer(params)
with proxy_server.get_requests_session(
    ProxyProtocol.https,
    headers=headers,
    verify=ssl_verify) as session:
    post_response = session.post(token_url, json=payload)
    delete_response = session.delete(delete_user_url)

session will be closed on exiting the with block

- Use session with SSL context in post request (which accepts everything requests.request accepts)

proxy_server = ConnectProxyServer(params)

session =proxy_server.get_requests_session(ProxyProtocol.https,headers=device_headers, verify=ssl_verify)

add_response = session.post(add_user_url, json=json_body)

get_response = session.get(get_user_url)

proxy_server = ConnectProxyServer(params)

session = proxy_server.get_requests_session(ProxyProtocol.https)

add_response = session.post(add_user_url, json=json_body, verify=ssl_verify, headers=headers)
</code></pre>
<p>:param self:</p>
<p>:param protocol: Proxies to use in the session for the proxy server if
proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
or ProxyProtocol.none. Default is ProxyProtocol.https.
This sets the session proxies, auth in HTTPProxyAuth and trust_env.</p>
<p>:param kwargs: (optional) Any arguments that requests.session supports,
except proxies, auth and trust_env, passed as "headers=headerValue",
for example. User can also pass the value via session methods such as
post, get, delete etc. you can also pass use_cache=true which will
persist in connection pool. By default we don't cache the connection in
the connection pool.</p>
<p>:return: A requests.session that has proxy server configured.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_requests_session(self, protocol=ProxyProtocol.https, **kwargs):
    &#34;&#34;&#34; Get a requests session with proxy server info set.

    Method will check if the proxy is enabled or not. And after getting
    the requests session, user can use post, delete, put whatever
    requests session supports to invoke a http request. By using this
    method, user proxy server is transparent to the user. The proxy
    server configuration is set. Check sessions to see what variables can
    be passed in details:

    https://requests.readthedocs.io/en/master/api/#request-sessions

    Typical usage example:

        - Use session with headers and verify SSL context (accepts most of requests.Session accepts)

        proxy_server = ConnectProxyServer(params)
        with proxy_server.get_requests_session(
            ProxyProtocol.https,
            headers=headers,
            verify=ssl_verify) as session:
            post_response = session.post(token_url, json=payload)
            delete_response = session.delete(delete_user_url)

        session will be closed on exiting the with block

        - Use session with SSL context in post request (which accepts everything requests.request accepts)

        proxy_server = ConnectProxyServer(params)

        session =proxy_server.get_requests_session(ProxyProtocol.https,headers=device_headers, verify=ssl_verify)

        add_response = session.post(add_user_url, json=json_body)

        get_response = session.get(get_user_url)

        proxy_server = ConnectProxyServer(params)

        session = proxy_server.get_requests_session(ProxyProtocol.https)

        add_response = session.post(add_user_url, json=json_body, verify=ssl_verify, headers=headers)

    :param self:

    :param protocol: Proxies to use in the session for the proxy server if
    proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
    or ProxyProtocol.none. Default is ProxyProtocol.https.
    This sets the session proxies, auth in HTTPProxyAuth and trust_env.

    :param kwargs: (optional) Any arguments that requests.session supports,
    except proxies, auth and trust_env, passed as &#34;headers=headerValue&#34;,
    for example. User can also pass the value via session methods such as
    post, get, delete etc. you can also pass use_cache=true which will
    persist in connection pool. By default we don&#39;t cache the connection in
    the connection pool.

    :return: A requests.session that has proxy server configured.
    &#34;&#34;&#34;
    # By default, we don&#39;t put the connection back to the connection pool
    # So each session is a new connection. User can chose to use default
    # connection pool, then connection from connection pool would persist
    if kwargs.get(&#34;use_cache&#34;):
        self.set_default_connection_pool()
    else:
        self.set_no_cache_connection_pool()

    session = requests.Session()
    if self.is_enabled:
        proxies = self.get_proxies(protocol)
        # Set proxy ones for entire session
        session.auth = HTTPProxyAuth(self.username, self.password)
        session.proxies.update(proxies)
        self.proxies = proxies
    else:
        proxies = self.get_empty_proxies_string()
        session.proxies.update(proxies)
        session.auth = None
        self.proxies = proxies
    # Not trusting default env
    session.trust_env = False

    # Set the variables that session supports. Not including proxies,
    # auth and trust_env. However, There is nothing prevents caller to
    # get the session first then override proxies, auth and trust_env
    if kwargs.get(&#34;cert&#34;):
        session.cert = kwargs.get(&#34;cert&#34;)
    if kwargs.get(&#34;cookies&#34;):
        session.cookies = kwargs.get(&#34;cookies&#34;)
    if kwargs.get(&#34;headers&#34;):
        session.headers = kwargs.get(&#34;headers&#34;)
    if kwargs.get(&#34;hooks&#34;):
        session.hooks = kwargs.get(&#34;hooks&#34;)
    if kwargs.get(&#34;max_redirects&#34;):
        session.max_redirects = kwargs.get(&#34;max_redirects&#34;)
    if kwargs.get(&#34;params&#34;):
        session.params = kwargs.get(&#34;params&#34;)
    if kwargs.get(&#34;stream&#34;):
        session.stream = kwargs.get(&#34;stream&#34;)
    if kwargs.get(&#34;verify&#34;):
        session.verify = kwargs.get(&#34;verify&#34;)
    return session</code></pre>
</details>
</dd>
<dt id="connectproxyserver.ConnectProxyServer.get_urllib_request_https_opener"><code class="name flex">
<span>def <span class="ident">get_urllib_request_https_opener</span></span>(<span>self, protocol=ProxyProtocol.https, ssl_context=None, basic_auth=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a urllib request opener with proxy server configured with
ssl_context and HTTP basic auth handler set.</p>
<p>Similar to method get_urllib_request_opener, if you want methods to
set ssl_context and basic auth. The method has HTTPSHandler with SSL
context and HTTPBasicAuthHandler set for the opener. User can use
opener.open or urllib.request.urlopen after this method to connect to
invoke a http request.</p>
<p>Typical usage example:</p>
<pre><code>- Use urlopen with ssl_context and HTTPPasswordMgrWithDefaultRealm

password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()

password_mgr.add_password(None, https_url, https_client_id, https_client_secret)

proxy_server = AppProxyServer(params)

opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context, password_mgr)

response = urllib.request.urlopen(CrowdStrike_HTTPS_URL)

- Use urlopen, with ssl_context

proxy_server = AppProxyServer(params)

opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

http_post_request = urllib.request.Request(https_url, http_post_data.encode('utf-8'), method='POST')

http_post_request.add_header("Content-Type", "application/x-www-form-urlencoded")

http_post_request.add_header("accept", "application/json")

# Use opener.open to get the request ( you can use urlopen as well, look at resolve script
response = urllib.request.urlopen(http_post_request)

- Use open, with ssl_context

proxy_server = ConnectProxyServer(params)

opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

poll_request = urllib.request.Request(get_mac_url, headers=device_headers)

poll_response = opener.open(poll_request)
</code></pre>
<p>Check out HTTPBasicAuthHandler, see:
<a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPPasswordMgr">https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPPasswordMgr</a></p>
<p>:param protocol: Proxies to use in the session for the proxy server if
proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
or ProxyProtocol.none. Default is ProxyProtocol.https.</p>
<p>:param ssl_context: ssl_context passed to the context in the
HTTPSHandler. Default is None.</p>
<p>:param basic_auth:
HTTPPasswordMgr or similar passed to create HTTPBasicAuthHandler.
Default is None.</p>
<p>:return: opener: OpenerDirector from urllib.request.build_opener that
has ProxyHandler, HTTPSHandler with SSL context and
HTTPBasicAuthHandler set. The consequent request call can use
opener.open or urllib.request.urlopen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_urllib_request_https_opener(self, protocol=ProxyProtocol.https, ssl_context=None, basic_auth=None):
    &#34;&#34;&#34; Get a urllib request opener with proxy server configured with
    ssl_context and HTTP basic auth handler set.

    Similar to method get_urllib_request_opener, if you want methods to
    set ssl_context and basic auth. The method has HTTPSHandler with SSL
    context and HTTPBasicAuthHandler set for the opener. User can use
    opener.open or urllib.request.urlopen after this method to connect to
    invoke a http request.

    Typical usage example:

        - Use urlopen with ssl_context and HTTPPasswordMgrWithDefaultRealm

        password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()

        password_mgr.add_password(None, https_url, https_client_id, https_client_secret)

        proxy_server = AppProxyServer(params)

        opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context, password_mgr)

        response = urllib.request.urlopen(CrowdStrike_HTTPS_URL)

        - Use urlopen, with ssl_context

        proxy_server = AppProxyServer(params)

        opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

        http_post_request = urllib.request.Request(https_url, http_post_data.encode(&#39;utf-8&#39;), method=&#39;POST&#39;)

        http_post_request.add_header(&#34;Content-Type&#34;, &#34;application/x-www-form-urlencoded&#34;)

        http_post_request.add_header(&#34;accept&#34;, &#34;application/json&#34;)

        # Use opener.open to get the request ( you can use urlopen as well, look at resolve script
        response = urllib.request.urlopen(http_post_request)

        - Use open, with ssl_context

        proxy_server = ConnectProxyServer(params)

        opener = proxy_server.get_urllib_request_https_opener(ProxyProtocol.https, ssl_context)

        poll_request = urllib.request.Request(get_mac_url, headers=device_headers)

        poll_response = opener.open(poll_request)


    Check out HTTPBasicAuthHandler, see:
    https://docs.python.org/3/library/urllib.request.html#urllib.request.HTTPPasswordMgr

    :param protocol: Proxies to use in the session for the proxy server if
    proxy server is enabled, can be ProxyProtocol.https, ProxyProtocol.http
    or ProxyProtocol.none. Default is ProxyProtocol.https.

    :param ssl_context: ssl_context passed to the context in the
    HTTPSHandler. Default is None.

    :param basic_auth:
    HTTPPasswordMgr or similar passed to create HTTPBasicAuthHandler.
    Default is None.

    :return: opener: OpenerDirector from urllib.request.build_opener that
    has ProxyHandler, HTTPSHandler with SSL context and
    HTTPBasicAuthHandler set. The consequent request call can use
    opener.open or urllib.request.urlopen.
    &#34;&#34;&#34;
    if ssl_context:
        https_handler = urllib.request.HTTPSHandler(context=ssl_context)
    else:
        https_handler = urllib.request.HTTPSHandler()
    if self.is_enabled:
        proxies = self.get_proxies(protocol)
        proxy_handler = urllib.request.ProxyHandler(proxies)
        self.proxies = proxies
    else:
        self.proxies = self.get_empty_proxies_string()

    if basic_auth:
        auth_handler = urllib.request.HTTPBasicAuthHandler(basic_auth)
    else:
        auth_handler = urllib.request.HTTPBasicAuthHandler()

    if self.is_enabled:
        opener = urllib.request.build_opener(proxy_handler, auth_handler, https_handler)
    else:
        opener = urllib.request.build_opener(auth_handler, https_handler)

    # This is needed to able opener to able to call urlopen
    urllib.request.install_opener(opener)
    return opener</code></pre>
</details>
</dd>
<dt id="connectproxyserver.ConnectProxyServer.get_urllib_request_opener"><code class="name flex">
<span>def <span class="ident">get_urllib_request_opener</span></span>(<span>self, protocol=ProxyProtocol.https, *handlers)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a urllib request opener with proxy server configured</p>
<p>Get a request opener that can has proxy server set and user can use
opener.open or urllib.request.urlopen after this method to connect to
invoke a http request. To check out opener,
see: <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.build_opener">https://docs.python.org/3/library/urllib.request.html#urllib.request.build_opener</a></p>
<p>Typical usage example:</p>
<pre><code>-  Use open, pass handlers

auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

ssl_handler = urllib.request.HTTPSHandler(context=ssl_context)

proxy_server = AppProxyServer(params)

opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

response = opener_build_opener.open(https_url)

- Use urlopen, pass handlers

proxy_server = AppProxyServer(params)

opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

response = urllib.request.urlopen(https_url)

- Use urlopen, pass info on request

proxy_server = ConnectProxyServer(params)

# HTTPS or HTTP or both in the protocol, pass down the ssl_context
https_handler = urllib.request.HTTPSHandler(context=ssl_context)

opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, https_handler)

get_user_request = urllib.request.Request(get_users_url, headers=device_headers)

get_user_response = urllib.request.urlopen(get_user_request)
</code></pre>
<p>:param protocol: Proxies to use in the request for the proxy server
If proxy server is enabled, can be ProxyProtocol.https,
ProxyProtocol.http or ProxyProtocol.none. Default is
ProxyProtocol.https.</p>
<p>:param handlers: (optional) Handlers that urllib.request.build_opener accepts, such as HTTPSHandler.</p>
<p>:return: opener: OpenerDirector from urllib.request.build_opener that has ProxyHandler set. The consequent
request call can use opener.open or urllib.request.urlopen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_urllib_request_opener(self, protocol=ProxyProtocol.https, *handlers):
    &#34;&#34;&#34; Get a urllib request opener with proxy server configured

    Get a request opener that can has proxy server set and user can use
    opener.open or urllib.request.urlopen after this method to connect to
    invoke a http request. To check out opener,
    see: https://docs.python.org/3/library/urllib.request.html#urllib.request.build_opener

    Typical usage example:

        -  Use open, pass handlers

        auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

        ssl_handler = urllib.request.HTTPSHandler(context=ssl_context)

        proxy_server = AppProxyServer(params)

        opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

        response = opener_build_opener.open(https_url)

        - Use urlopen, pass handlers

        proxy_server = AppProxyServer(params)

        opener_build_opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, auth_handler, ssl_handler)

        response = urllib.request.urlopen(https_url)

        - Use urlopen, pass info on request

        proxy_server = ConnectProxyServer(params)

        # HTTPS or HTTP or both in the protocol, pass down the ssl_context
        https_handler = urllib.request.HTTPSHandler(context=ssl_context)

        opener = proxy_server.get_urllib_request_opener(ProxyProtocol.https, https_handler)

        get_user_request = urllib.request.Request(get_users_url, headers=device_headers)

        get_user_response = urllib.request.urlopen(get_user_request)

    :param protocol: Proxies to use in the request for the proxy server
    If proxy server is enabled, can be ProxyProtocol.https,
    ProxyProtocol.http or ProxyProtocol.none. Default is
    ProxyProtocol.https.

    :param handlers: (optional) Handlers that urllib.request.build_opener accepts, such as HTTPSHandler.

    :return: opener: OpenerDirector from urllib.request.build_opener that has ProxyHandler set. The consequent
    request call can use opener.open or urllib.request.urlopen.
    &#34;&#34;&#34;
    if self.is_enabled:
        proxies = self.get_proxies(protocol)
        proxy_handler = urllib.request.ProxyHandler(proxies)
        opener = urllib.request.build_opener(proxy_handler, *handlers)
        self.proxies = proxies
    else:
        proxy_handler = urllib.request.ProxyHandler({})
        opener = urllib.request.build_opener(proxy_handler, *handlers)
        self.proxies = self.get_empty_proxies_string()

    # This is needed to enable opener to able to call urllib.request.urlopen
    urllib.request.install_opener(opener)
    return opener</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="connectproxyserver.ProxyProtocol"><code class="flex name class">
<span>class <span class="ident">ProxyProtocol</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Choices for proxy server proxies</p>
<p>Indicate what proxy server proxies (string) shall use in the request. Can
be all, http, https or none. If proxy server supports both protocols,
can use ProxyProtocol.all. It is a good practise to use
ProxyProtocol.all if supporting both protocols. If only support http, then
use ProxyProtocol.http. If support https, then use ProxyProtocol.https.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProxyProtocol(Enum):
    &#34;&#34;&#34; Choices for proxy server proxies

    Indicate what proxy server proxies (string) shall use in the request. Can
    be all, http, https or none. If proxy server supports both protocols,
    can use ProxyProtocol.all. It is a good practise to use
    ProxyProtocol.all if supporting both protocols. If only support http, then
    use ProxyProtocol.http. If support https, then use ProxyProtocol.https.
    &#34;&#34;&#34;
    all = 1
    http = 2
    https = 3
    none = 4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="connectproxyserver.ProxyProtocol.all"><code class="name">var <span class="ident">all</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="connectproxyserver.ProxyProtocol.http"><code class="name">var <span class="ident">http</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="connectproxyserver.ProxyProtocol.https"><code class="name">var <span class="ident">https</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="connectproxyserver.ProxyProtocol.none"><code class="name">var <span class="ident">none</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="connectproxyserver.ConnectProxyServer" href="#connectproxyserver.ConnectProxyServer">ConnectProxyServer</a></code></h4>
<ul class="">
<li><code><a title="connectproxyserver.ConnectProxyServer.get_empty_proxies_string" href="#connectproxyserver.ConnectProxyServer.get_empty_proxies_string">get_empty_proxies_string</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.get_proxies" href="#connectproxyserver.ConnectProxyServer.get_proxies">get_proxies</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.get_requests_session" href="#connectproxyserver.ConnectProxyServer.get_requests_session">get_requests_session</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.get_urllib_request_https_opener" href="#connectproxyserver.ConnectProxyServer.get_urllib_request_https_opener">get_urllib_request_https_opener</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.get_urllib_request_opener" href="#connectproxyserver.ConnectProxyServer.get_urllib_request_opener">get_urllib_request_opener</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.set_default_connection_pool" href="#connectproxyserver.ConnectProxyServer.set_default_connection_pool">set_default_connection_pool</a></code></li>
<li><code><a title="connectproxyserver.ConnectProxyServer.set_no_cache_connection_pool" href="#connectproxyserver.ConnectProxyServer.set_no_cache_connection_pool">set_no_cache_connection_pool</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="connectproxyserver.ProxyProtocol" href="#connectproxyserver.ProxyProtocol">ProxyProtocol</a></code></h4>
<ul class="">
<li><code><a title="connectproxyserver.ProxyProtocol.all" href="#connectproxyserver.ProxyProtocol.all">all</a></code></li>
<li><code><a title="connectproxyserver.ProxyProtocol.http" href="#connectproxyserver.ProxyProtocol.http">http</a></code></li>
<li><code><a title="connectproxyserver.ProxyProtocol.https" href="#connectproxyserver.ProxyProtocol.https">https</a></code></li>
<li><code><a title="connectproxyserver.ProxyProtocol.none" href="#connectproxyserver.ProxyProtocol.none">none</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>